# Server Side Rendering

Tags: 과제

`create-react-app` 이 각광받다가 요즘은 서버 사이드 렌더링을 지원하는 Next.js같은 프레임 워크가 인기를 끌고 있다.

# 4.1 서버 사이드 렌더링이란?

---

## 4.1.1 싱글 페이지 애플리케이션의 세상

### 싱글 페이지 어플리케이션이란?

렌더링과 라우팅에 필요한 대부분의 기능을 서버가 아닌 브라우저의 자바스크립트의 의존하는 방식

최초의 첫 페이지에서 데이터를 모두 불러온 이후, 서버에서 HTML을 내려받지 않고 하나의 페이지에서 모든 작업을 처리.

즉, 최초의 서버에서 최소한의 데이터를 불러온 이후 이미 가지고 있는 소스들과 API로 모든 작동이 이뤄진다.

→ 사용자에게 훌륭한 UI/UX를 제공한다는 장점

### 전통적인 방식의 애플리케이션과 싱글 페이지 애플리케이션의 작동 비교

- 전통적인 방식

페이지 전환이 발생할 때마다 새롭게 페이지를 요청, HTML 페이지를 다운로드

→ 사용자 입장 : 페이지가 새로 만들어지는 것처럼 보임

- 싱글페이지

최초의 한 번 다소간의 로딩이 끝난 이후에는 페이지 전환이 모두 자바스크립트로 이루어짐

→ 주소는 변경되지만 매끄럽게 전환

### 싱글 페이지 렌더링 방식의 유행과 JAM 스택의 등장

- 싱글페이지의 등장

자바스크립트 : 보조적인 수단

→ 점차 모듈화하는 방안이 논의 되기 시작함

→ CommonJS, AMD 등장

→ 자바스크립트 수준에서 MVx 프레임워크를 구현

단순 UI/UX 를 위해서가 아닌, 프론트엔드 개발자들에게 간편한 개발 경험을 선사

- JAM 스택의 등장

대부분의 작업을 자바스크립트에서 수행할 수 있었기 때문에 JAM 스택이 인기를 얻을 수 있었다.

### 새로운 패러다임의 웹서비스를 향한 요구

인터넷 속도와 하드웨어 성능이 날이 갈수록 좋아짐

→ 자바스크립트 리소스의 크기와 수가 모두 증가하기 시작함

웹페이지 로딩속도

20초 → 15초 → 12초

## 4.1.2 서버 사이드 렌더링이란?

싱글페이지 어플리케이션 : 하나의 페이지에서만 렌더링을 수행

서버 사이드 렌더링 : 사용자에게 보여줄 페이지를 서버에서 렌더링해 빠르게 사용자에게 화면을 제공

둘의 차이는 웹페이지 렌더링의 책임을 어디에 두느냐

### 서버 사이드 렌더링의 장점

1. 최초 페이지 진입이 비교적 빠르다
서버가 사용자에게 렌더링을 제공할 수 있을 정도의 충분한 리소스가 확보돼 있다는 일반적인 가정하에
2. 검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다
1) 검색 엔진 로봇이 페이지에 진입
2) 페이지가 HTML 정보를 제공해 로봇이 이 HTML을 다운로드 한다. 실행은 X
3) 페이지 내부의 오픈 그래프나 메타 태그 정보를 기반으로 검색엔진에 저장
검색 엔진에 제공할 정보를 서버에서 가공해서 HTML 응답으로 제공할 수 있으므로 검색 엔진 최적화에 대응하기가 매우 용이함
3. 누적 레이아웃 이동이 적다
싱글페이지 : 페이지 콘텐츠가 API요청에 의존하고, 응답 속도가 제각각이면 누적 레이아웃 이동 문제가 발생할 수도 있다.
4. 사용자의 디바이스 성능에 비교적 자유롭다
절대적으로 사용자의 디바이스 성능에 의존적이었다면, 서버에 이 부담을 나눌 수 있음
5. 보안에 좀 더 안전하다
API 호출이나 사용자에게 노출되면 안되는 작업이 포함

### 단점

1. 소스코드를 작성할 때 항상 서버를 고려해야 한다
window 또는 sessionStorage와 같이 브라우저에만 있는 전역 객체
만약 서버에서 실행된다면 `window is not defined` 라는 에러를 만남
2. 적절한 서버가 구축돼 있어야 한다
렌더링을 수행할 서버가 필요하고, 서버를 구축하는 것은 절대 쉬운 일이 아님
3. 서비스 지연에 따른 문제
싱글페이지 : 로딩중 이라는 화면 띄우기 가능
서버 사이드 렌더링 : 렌더링 작업이 끝날 때까지 전달할 수 있는 것이 없음

# 4.2 서버 사이드 렌더링을 위한 리액트 API 살펴보기

---

window가 아닌 Node.js 와 같은 환경에서만 실행 가능

리액트에서 서버 사이드 렌더링을 실행할 때 사용되는 API를 확인해 보려면 `react-dom/server.js`

4개의 함수를 소개

## 4.2.1 renderToString

: 인수로 넘겨받은 리액트 컴포넌트를 렌더링해 HTML 문자열로 반환하는 함수

가장 기초적인 API

```jsx
const result = ReactDOMServer.renderToString(
	React.createElement( 'div', {id: root}, ... ),
)
```

… 에 들어가는 내용이 HTML 결과로 나옴

자바스크립트 코드를 포함시키거나 렌더링하는 역할까지 해주지는 않음

```jsx
<div id="root" data-reactroot="">
...
</div>
```

`data-reactroot` : hydrate 함수에서 루트를 식별하는 기준점이 된다.

## 4.2.2 renderToStaticMarkup

: renderToString 과 매우 유사한 함수이다. 차이점은 data-reactroot와 같은 리액트에서만 사용하는 추가적인 DOM 속성을 만들지 않는다는 점이다.

→ HTML의 크기를 아주 약간이라도 줄일 수 있다는 장점

```jsx
<div id="root">
...
</div>
```

아까와 같은 코드로 함수만 변경하여 출력하면, data-reactroot 가 사라진 것을 볼 수 있다.

renderToStaticMarkup 은 완전히 순수한 HTML 을 만들때만 사용된다.

`정적인 내용` : 블로그, 상품의 약관정보 와 같은 브라우저 액션이 없는 정보들로 구성

## 4.2.3 renderToNodeStream

renderToString 과 결과물이 완전히 동일하지만 두 가지의 차이점이 있다.

1. renderToString과 달리 브라우저에서 사용하는 것이 완전히 불가능하다.
2. 결과물의 타입

renderToString = string

renderToNodeStream = utf-8 바이트스트림

**WHY?**

스트림의 개념: 큰 데이터를 다룰 때 데이터를 청크(작은단위)로 분할해 조금씩 가져오는 방식
→ 유튜브 스트리밍과 비슷한 개념

renderToString 의 단위가 매우 커질 경우, 서버에 부담이 될 수 있다.

이때, 청크단위로 가져오는 스트림을 활용

## 4.2.4 renderToStaticNodeStream

renderToString-renderToStaticMarkup

renderToNodeStream-renderToStaticNodeStream

hydrate를 할 필요가 없는 순수 HTML 결과물이 필요할 때 사용하는 메서드

## 4.2.5 hydrate

HTML 콘텐츠에 자바스크립트 핸들러나 이벤트를 붙이는 역할

**render**

```jsx
ReactDOM.render(<App />,rootElement)
```

컴포넌트와 HTML의 요소를 인수로 받음

**hydrate**

```jsx
ReactDOM.render(<App />,element)
```

render 와의 차이점은

- hydrate는 기본적으로 이미 렌더링된 HTML이 있다는 가정하에 작업수행

→ rootElement 내부에는 <App /> 을 렌더링한 정보가 이미 포함돼 있어야함 !!

⇒ 정적인 HTML 정보가 담겨 있어야 렌더링 할 수 있음

`경고를 일시적으로 끄는 방법 : suppressHydrationWarning`