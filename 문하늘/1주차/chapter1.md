# 01장 | 리액트 개발을 위해 꼭 알아야 할 자바스크립트
## 1.1 자바스크립트의 동등 비교
### 1.1.1 자바스크립트의 데이터 타입
	원시타입과 객체 타입 
		☞ 원시타입 : boolean, null, undefined, number, string, symbol, bight
		 - undefined : 선언됐지만 할당되지 않은 값
  		 - null : 명시적으로 비어 있음을 나타내는 값
		☞ 객체타입 : object(배열, 함수, 정규식, 클래스 등)
### 1.1.2 값을 저장하는 방식의 차이
	원시 타입은 값을 저장하고 객체는 참조를 저장한다. 
### 1.1.3 자바스크립트의 또 다른 비교 공식, Object.js
	Object.js : 두 개의 인수를 받으며, 인수 두 개가 동일한지 확인하고 반환하는 메서드
	 • == vs. Object.js : == 비교는 같음을 비교하기 전에 양쪽이 같은 타입이 아니라면 비교할 수 있도록 강제로 형변환을 한 후에 비교한다.
	 • === vs. Object.js : Object.is 가 개발자가 기대하는 방식으로 더 잘 비교함
### 1.1.4 리액트에서의 동등 비교
	리액트에서는 objectIs를 기반으로 동등 비교를 하는 shallowEqual이라는 함수를 사용함
		☞ shallowEqual: Object.is로 먼저 비교 후 Object.is에서 수행하지 못한 객체 간 얕은 비교를 한 번 더 수행
### 1.1.5 정리
	☆ 자바스크립트에서 객체 비교의 불완전성은 스칼라나 하스켈 등의 다른 함수형 언어에서는 볼 수 없는 중요한 특징
	☆ 이러한 자바스크립트를 기반으로 한 리액트의 함수형 프로그래밍 모델에서도 이러한 언어적인 한계를 뛰어넘을 수 없으므로 얕은 비교만을 사용해 비교를 수행해 필요한 기능을 구현하고 있음

## 1.2 함수
### 1.2.1 함수란 무엇인가?
	함수 : 작업을 수행하거나 값을 계산하는 등의 과정을 표현하고, 이를 하나의 블록으로 감싸서 실행 단위로 만들어 놓은 것
	☞ 함수의 기본적인 형태
	function sum(a, b) {
		return a + b
	}
	sum(10, 24)
	☞ 리액트에서 컴포넌트를 만드는 함수
	function Component(props) {
		return <div>{props.hello}</div>
	}
### 1.2.2 함수를 정의하는 4가지 방법
	1. 함수 선언문
	function sum(a, b) {
		return a + b
	}
	
	2. 함수 표현식
	• 일급 객체 : 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체
	• 자바스크립트에서 함수는 일급 객체
	• 함수 표현식은 혼란을 방지하기 위해 할당하려는 함수의 이름을 생략하는 것이 일반적임
	const sum = function add(a, b) {
		console.log(arguments.callee.name)
		return a + b
	}
	sum(10, 24)
	add(10, 24) ---> error !!

	☞ 함수 표현식과 선언 식의 차이
	• 함수 호이스팅 : 함수에 대한 선언을 실행 전에 미리 메모리에 등록하는 작업
	• 함수 표현식은 함수를 변수에 할당
	• 함수와 다르게 변수는 런타임 이전에 undifined로 초기화되고, 런타임 시점에 함수가 할당되어 작동
	
	3. Function 생성자 -> 실제 코딩에서 사용되지 않음
	const add = new Function('a', 'b', 'return a+b')
	add(10, 24)

	4. 화살표 함수
	• 생성자 함수로 화살표 함수를 사용하는 것은 불가능
	• 화살표 함수에서는 arguments가 존재하지 않음
	const add = (a,b) => {
		return a + b
	}
	const add = (a,b) => a + b

	☞ 화살표 함수와 일반 함수의 차이 : this
	• this : 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값
	