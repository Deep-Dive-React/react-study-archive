# 01장 | 리액트 개발을 위해 꼭 알아야 할 자바스크립트
## 1.1 자바스크립트의 동등 비교
### 1.1.1 자바스크립트의 데이터 타입
	원시타입과 객체 타입 
		☞ 원시타입 : boolean, null, undefined, number, string, symbol, bight
		 - undefined : 선언됐지만 할당되지 않은 값
  		 - null : 명시적으로 비어 있음을 나타내는 값
		☞ 객체타입 : object(배열, 함수, 정규식, 클래스 등)
### 1.1.2 값을 저장하는 방식의 차이
	원시 타입은 값을 저장하고 객체는 참조를 저장한다. 
### 1.1.3 자바스크립트의 또 다른 비교 공식, Object.js
	Object.js : 두 개의 인수를 받으며, 인수 두 개가 동일한지 확인하고 반환하는 메서드
	 • == vs. Object.js : == 비교는 같음을 비교하기 전에 양쪽이 같은 타입이 아니라면 비교할 수 있도록 강제로 형변환을 한 후에 비교한다.
	 • === vs. Object.js : Object.is 가 개발자가 기대하는 방식으로 더 잘 비교함
### 1.1.4 리액트에서의 동등 비교
	리액트에서는 objectIs를 기반으로 동등 비교를 하는 shallowEqual이라는 함수를 사용함
		☞ shallowEqual: Object.is로 먼저 비교 후 Object.is에서 수행하지 못한 객체 간 얕은 비교를 한 번 더 수행
### 1.1.5 정리
	☆ 자바스크립트에서 객체 비교의 불완전성은 스칼라나 하스켈 등의 다른 함수형 언어에서는 볼 수 없는 중요한 특징
	☆ 이러한 자바스크립트를 기반으로 한 리액트의 함수형 프로그래밍 모델에서도 이러한 언어적인 한계를 뛰어넘을 수 없으므로 얕은 비교만을 사용해 비교를 수행해 필요한 기능을 구현하고 있음

## 1.2 함수
### 1.2.1 함수란 무엇인가?
	함수 : 작업을 수행하거나 값을 계산하는 등의 과정을 표현하고, 이를 하나의 블록으로 감싸서 실행 단위로 만들어 놓은 것
	☞ 함수의 기본적인 형태
	function sum(a, b) {
		return a + b
	}
	sum(10, 24)
	☞ 리액트에서 컴포넌트를 만드는 함수
	function Component(props) {
		return <div>{props.hello}</div>
	}
### 1.2.2 함수를 정의하는 4가지 방법
	1. 함수 선언문
	function sum(a, b) {
		return a + b
	}
	
	2. 함수 표현식
	• 일급 객체 : 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체
	• 자바스크립트에서 함수는 일급 객체
	• 함수 표현식은 혼란을 방지하기 위해 할당하려는 함수의 이름을 생략하는 것이 일반적임
	const sum = function add(a, b) {
		console.log(arguments.callee.name)
		return a + b
	}
	sum(10, 24)
	add(10, 24) ---> error !!

	☞ 함수 표현식과 선언 식의 차이
	• 함수 호이스팅 : 함수에 대한 선언을 실행 전에 미리 메모리에 등록하는 작업
	• 함수 표현식은 함수를 변수에 할당
	• 함수와 다르게 변수는 런타임 이전에 undifined로 초기화되고, 런타임 시점에 함수가 할당되어 작동
	
	3. Function 생성자 -> 실제 코딩에서 사용되지 않음
	const add = new Function('a', 'b', 'return a+b')
	add(10, 24)

	4. 화살표 함수
	• 생성자 함수로 화살표 함수를 사용하는 것은 불가능
	• 화살표 함수에서는 arguments가 존재하지 않음
	const add = (a,b) => {
		return a + b
	}
	const add = (a,b) => a + b

	☞ 화살표 함수와 일반 함수의 차이 : this
	• this : 자신이 속한 객체나 자신이 생성할 인스턴스를 가리키는 값
	
### 1.2.3 다양한 함수 살펴보기
	1. 즉시 실행 함수 
	• 함수를 정의하고 그 순간 즉시 실행되는 함수. 단 한 번만 호출됨
	• 글로벌 스코프를 오염시키지 않는 독립적인 함수 스코프를 운용할 수 있음
	2. 고차 함수
	• 고차 함수 컴포넌트를 만들면 컴포넌트 내부에서 공통으로 관리되는 로직을 분리해 관리할 수 있어 효율적으로 리팩터링 가능

### 1.2.4 함수를 만들 때 주의해야 할 사항
	1. 함수 부수 효과를 최대한 억제하라
		• 함수의 부수 효과 : 함수 내의 작동으로 인해 함수가 아닌 함수 외부에 영향을 끼치는 것
		• 순수 함수 : 부수 효과가 없고, 언제 어디서나 어떠한 상황에서든 동일한 인수를 받으면 동일한 결과를 반환해야 함
		부수 효과는 웹 애플리케이션 개발에 있어 피할 수 없는 요소지만 부수 효과를 최대한 억제할 수 있는 방향으로 함수를 설계해야 함
	2. 가능한 한 함수를 작게 만들어라
	3. 누구나 이해할 수 있는 이름을 붙여라

## 1.3 클래스
### 1.3.1 클래스란 무엇인가?
	클래스 : 특정한 형태의 객체를 반복적으로 만들기 위해 사용하는 것
	1. 생성자 
		• 객체를 생성하는 데 사용하는 특수한 메서드
		• 단 하나만 존재할 수 있음
	2. 프로퍼티
		• 클래스로 인스턴스를 생성할 때 내부에 정의할 수 있는 속성값
	3. getter와 setter
		• getter : 클래스에서 무언가 값을 가져올 때 사용
		• setter : 클래스 필드에 값을 할당할 때 사용
	4. 인스턴스 메서드
		• 클래스 내부에서 선언한 메서드
	5. 정적 메서드
		• 클래스의 인스턴스가 아닌 이름으로 호출할 수 있는 메서드
	6. 상속
		
### 1.3.2 클래스와 함수의 관계
	클래스 작동을 생성자 함수로 매우 유사하게 재현할 수 있음

## 1.4 클로저
### 1.4.1 클로저의 정의
	• 클로저 : 함수와 함수가 선언된 어휘적 환경의 조합 

### 1.4.2 변수의 유효 범위, 스코프
	• 스코프 : 변수의 유효 범위

	1. 전역 스코프 : 전역 레벨에 선언하는 것
	2. 함수 스코프

### 1.4.3 클로저의 활용
	• 변수를 직접 노출하지 않음으로써 사용자가 직접 수정하는 것을 막을 수 있음
	• 접근하는 경우를 제한해 로그를 남기는 등의 부차적인 작업도 수행 가능

	☞ 리액트에서의 클로저
	클로저의 원리를 사용하고 있는 대표적인 것 중 하나가 바로 useState

### 1.4.4 주의할 점
	클로저는 생성될 때마다 그 선언적 환경을 기억해야 하므로 추가로 비용이 발생함

## 1.5 이벤트 루프와 비동기 통신의 이해
	• 자바스크립트는 기본적으로 한 번에 하나의 작업만 동기 방식으로 처리하지만 비동기 작업도 이루어짐
	• 동기 : 직렬 방식으로 작업을 처리하는 것
	• 비동기 : 정렬 방식으로 작업을 처리하는 것

### 1.5.1 싱글 스레드 자바스크립트
	• 프로세스 : 하나의 프로그램 실행은 하나의 프로세스를 가지고 그 프로세스 내부에서 모든 작업이 처리되는 것
	• 스레드 : 프로세스의 더 작은 실행 단위
	하나의 프로세스에는 여러 개의 스레드를 만들 수 있고, 스레드끼리는 메모리를 공유할 수 있어 여러 가지 작업을 동시에 수행 가능하다.
	☞ 싱글 스레드 자바스크립트 : 코드를 한 줄 한 줄 실행하여 하나의 작업이 끝나기 전까지는 뒤이은 작업이 실행되지 않음

### 1.5.2 이벤트 루프란?
	• 이벤트 루프 : 자바스크립트 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치
	
	1. 호출 스택과 이벤트 루프
	• 호출 스택 : 자바스크립트에서 수행해야 할 코드나 함수를 순차적으로 담아두는 스택
	☞ 이 호출 스택이 비어 있는지 여부를 확인하는 것이 이벤트 루프
	• 테스트 큐 : 실행해야 할 태스크의 집합
	☞ 이벤트 루프는 태스크 큐를 한 개 이상 가지고 있으며 호출 스택에 실행 중인 코드가 있는지, 그리고 테스트 큐에 대기 중인 함수가 있는지 반복해서 확인하는 역할을 한다.

### 1.5.3 태스크 큐와 마이크로 태스크 큐
	• 태스크 큐 : setTimeout, setInterval, setImmediate
	• 마이크로 큐 : process.nextTick, Promisses, queueMicroTask, MutationObserver
	- 이벤트 루프는 하나의 마이크로 태스크 큐를 갖고 있음
	- 마이크로 태스크 큐는 기존 태스크 큐보다 우선권을 가짐
	- 동기 코드는 물론 마이크로 태스크 또한 렌더링에 영향을 미칠 수 있음
	
## 1.6 리액트에서 자주 사용하는 자바스크립트 문법
	• 바벨 : 자바스크립트의 최신 문법을 다양한 브라우저에서도 일관적으로 지원할 수 있도록 코드를 트랜스파일함

### 1.6.1 구조 분해 할당
	• 구조 분해 할당 : 배열 또는 객체의 값을 분해해 개별 변수에 즉시 할당하는 것
	• 구조 분해 할당은 자유롭게 이름을 선언할 수 있음
	• 객체 구조 분해 할당 : 객체에서 값을 꺼내온 뒤 할당하는 것
	☞ 배열 구조 분해 할당과 달리, 객체는 객체 내부 이름으로 꺼내온다는 차이가 있음

### 1.6.2 전개 구문
	• 전개구문 : 배열이나 객체, 문자열과 같이 순회할 수 있는 값에 대해 간결하게 사용할 수 있는 구문

	1. 배열의 전개 구문
	전개 구문을 활용하면 쉽게 배열을 합성할 수 있다.
	2. 객체의 전개 구문
	객체를 합성하는 데 있어 마찬가지로 편리함을 가져다 준다.
	- 전개 구문 이후에 값 할당이 있다면 이전 구문 값을 덮어씀
	- 반대의 경우는 전개 구문이 해당 값을 덮어씀
	- 객체 전개 연산자도 트랜스파일되면 번들링이 커져 주의

### 1.6.3 객체 초기자
	• 객체 초기자 : 객체를 선언할 때 객체에 넣고자 하는 키와 값을 가지고 있는 변수가
	  이미 존재하면 해당 값을 간결하게 넣어줄 수 있는 방식
	
### 1.6.4 Array 프로토타입의 메서드: map, filter, reduce, forEach
	1. Array.prototype.map
	인수로 전달받은 배열과 똑같은 길이의 새로운 배열을 반환하는 메서드
	2. Array.prototype.filter
	filter의 결과에 따라 원본 배열의 길이 이하의 새로운 배열 반환
	3. Array.prototype.reduce
	콜백 함수를 실행하고, 이를 초깃값에 누적해 결과 반환
	4. Array.prototype.forEach
	콜백 함수를 실행하기만 하는 메서드
    - forEach를 사용할 때는 중간에 순회를 멈출 수 없음

### 1.6.5 삼항 조건 연산자
	• 삼항 조건 연산자 : 3개의 피연산자를 취할 수 있는 문법
	조건문 ? 참일_때_값 : 거짓일_때_값

## 1.7 선택이 아닌 필수, 타입스크립트
### 1.7.1 타입스크립트란?
	• 타입스크립트는 타입 체크를 정적으로 런타임이 아닌 빌드 타임에 수행할 수 있게 해줌

### 1.7.2 리액트 코드를 효과적으로 작성하기 위한 타입스크립트 활용법
	1. any 대신 unknown을 사용하자
	2. 타입 가드를 적극 활용하자
	3. 제네릭
	4. 인덱스 시그니처

### 1.7.3 타입스크립트 전환 가이드
	1. JSDoc과 @ts-check를 활용해 점진적으로 전환하기
	2. 타입 기반 라이브러리 사용을 위해 @types 모듈 설치하기
	3. 파일 단위로 조금씩 전환하기