# 02장 | 리액트 핵심 요소 깊게 살펴보기
## 2.1 JSX란?
### 2.1.1 JSX의 정의
1. JSXElement
JSX를 구성하는 가장 기본 요소
    [JSXElement가 되기 위한 방법]
    ▪ JSXOpeningElement:일반적으로 볼 수 있는 요소
    ▪ JSXClosingElement:JSXOpeningElement가 종료됐음을 알리는 요소
    ▪ JSXSelfClosingElement:요소가 시작되고 스스로 종료되는 형태
    ▪ JSXFragment:아무런 요소가 없는 형태 
JSXElementName
JSXElement의 요소 이름으로 쓸 수 있는 것
    ▪ JSXIdentifier:JSX 내부에서 사용할 수 있는 식별자
    ▪ JSXNamespaceName:JSXIdentifier:JSXIdentifier의 조합
    ▪ JSXMemberExpression:JSXIdentifier.JSXIdentifier의 조합

2. JSXAttributes
JSXElement에 부여할 수 있는 속성. 존재하지 않아도 에러나지 않음
    ▪ JSXSpreadAttributes:자바스크립트의 전개 연산자와 동일한 역할
    ▪ JSXAttribute:속성을 나타내는 키와 값으로 짝을 이루어 표현
    ▻ JSXAttributeName:속성의 키값. JSXIdentifier, JSXNamespacedName 가능
    ▻ JSXAttributeValue:속성의 키에 할당할 수 있는 값

3. JSXChildren
JSXElement의 자식 값    
    ▪ JSXChild:JSXChildren을 이루는 기본 단위
4. JSXString
    [JSXString에서 사용 가능한 문자열]
    ▪ "큰따옴표로 구성된 문자열"
    ▪ '작은 따옴표로 구성된 문자열'
    ▪ JSXText
    ▪ \는 주의해서 사용

### 2.1.2 JSX 예제
```java
const ComponentA = <A>안녕하세요.</A>
const ComponentB = <A />
const ComponentC = <A {...{required: true}} />
const ComponentD = <A required />
const ComponentE = <A required={false}/>
const ComponentF = (
    <A>
        <B text="리액트" />
    </A>
)
const ComponentG = (
    <A>
        <B optionalChildren={<>안녕하세요.</>} />
    </A>
)
const ComponentH = (
    <A>
        안녕하세요
        <B text="리액트" />
    </A>
)
```

### 2.1.3 JSX는 어떻게 자바스크립트에서 변환될까?
@babel/plugin-transform-react-jsx 플러그인 또는 자동 런타임으로 트랜스파일 됨

### 2.1.4 정리
JSX 문법에는 있지만 실제로 리액트에서 사용하지 않는 것
    - JSXNamspacedName
    - JSXMemberExpression
리액트 내부에서 JSX가 어떻게 변환되는지, 어떤 결과물을 만들어내는지 알아두면 리액트 앱을 만드는 데 도움됨

## 2.2 가상 DOM과 리액트 파이버
### 2.2.1 DOM과 브라우저 렌더링 과정
1. 브라우저가 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드한다.
2. 브라우저의 렌더링 엔진은 HTML을 피싱해 DOM 노드로 구성된 트리(DOM)를 만든다.
3. 2번 과정에서 CSS 파일을 만나면 해당 CSS 파일도 다운로드한다.
4. 브라우저의 렌더링 엔진은 이 CSS도 피싱해 CSS 노드로 구성된 트리(CSSOM)를 만든다.
5. 브라우저는 2번에서 만든 DOM 노드를 순회하는데, 여기서 모든 노드를 방문하는 것이 아니고 사용자 눈에 보이는 노드만 방문한다. 
6. 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS 스타일 정보를 이 노드에 적용한다. 
[DOM 노드에 CSS를 적용하는 과정]
▪ 레이아웃 : 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정
▪ 페인팅 : 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정

### 2.2.2 가상 DOM의 탄생 배경
특정한 요소의 노출 여부 변경 및 사이즈 변경은 많은 비용을 브라우저와 사용자가 지불하게 한다.
추가 렌더링 작업은 싱글 페이지 애플리케이션에서 더욱 많아진다. 
사용자의 인터랙션에 따라 DOM의 모든 변경 사항을 추적하는 것은 개발자 입장에서 수고스럽다.
이러한 문제를 해결하기 위해 가상 DOM이 탄생했다.
##### 가상 DOM이란?
웹페이저가 표시해야 할 DOM을 일단 메모리에 저장하고 리액트가 실제 변경에 대한 준비가 됐을 때 실제 브라우저의 DOM에 반영하는 것
이를 통해 실제로는 렌더링 과정을 최소화하고 브라우저와 개발자의 부담을 덜 수 있다.
무조건 빠른 것이 아니라 가상 DOM 방식은 대부분 충분히 빠르다.

### 2.2.3 가상 DOM을 위한 아키텍처, 리액트 파이버
1. 리액트 파이버란?
리액트에서 관리하는 평범한 스크립트 객체
가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하여 차이가 있으면 관련 정보를 가지고 화면에 렌더링을 요청
*재조정:리액트에서 어떤 부분을 새롭게 렌더링해야 하는지 가상 DOM과 실제 DOM을 비교하는 작업
    [파이버가 반응성 문제를 해결하는 방법]
    ▪ 작업을 작은 단위로 분할하고 쪼갠 다음 우선순위를 매김
    ▪ 이러한 작업을 일시 중지하고 나중에 다시 시작할 수 있음
    ▪ 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우 폐기할 수 있음
    이 모든 과정이 비동기로 일어남, 즉 동시에 일어나지 않음
##### 파이버 구현 방식
1. 렌더단계 : 사용자에게 노출되지 않는 모든 비동기 작업을 수행한다. 우선순위를 지정하거나 중지시키는 등의 작업이 일어난다.
2. 커밋단계 : DOM에 실제 변경 사항을 반영하기 위한 작업, commitWork()가 실행된다. 이 과정은 앞서와 다르게 동기식으로 일어나고 중단될 수도 없다.
리액트 요소는 렌더링이 발생할 때마다 새롭게 생성되지만 파이버는 컴포넌트가 최초로 마운트되는 시점에 생성되어 이후에는 가급적이면 재사용된다.

##### 파이버 구현체에서 선언된 주요 속성
▪ tag:파이버는 하나의 element에 하나가 생성되는 1:1 관계를 가지고 있는데, 그 정보를 가지고 있는 것
▪ stateNode:파이버 자체에 대한 참조 정보를 가지고 있는 것
▪ child, sibling, return:파이버 간의 관계 개념을 나타내는 속성

생성된 파이버는 state가 변경되거나 생명주기 메서드가 실행되거나 DOM의 변경이 필요한 시점 등에 실행된다.
중요한 것은 리액트가 파이버를 처리할 때마다 이러한 작업을 직접 바로 처리하기도 하고 스케줄링하기도 한다는 것이다.

2. 리액트 파이버 트리
➀ 현재 모습을 담은 파이버 트리
➁ 작업 중인 상태를 나타내는 workInProgress 트리
#### 더블 버퍼링
리액트 파이버 작업이 끝나면 포인터만 변경하여 workInPregress트리를 현재 트리로 바꾸는 기술
- 현재 UI 렌더링을 위해 존재하는 트리인 current를 기준으로 모든 작업이 시작된다.
- 파이버는 업데이트가 발생하면 새로운 workInProgress 트리를 빌드한다.
- workInProgress 트리 빌드 작업이 끝나면 다음 렌더링에 이 트리를 사용한다.
- workInProgress 트리가 반영이 완료되면 current가 workInProgress로 변경된다.

### 2.2.4 파이버와 가상 DOM
파이버의 작업 순서
➀ 리액트는 beginWork() 함수를 실행해 파이버 작업을 수행하는데, 더 이상 자식이 없는 파이버를 만날 때까지 트리 형식으로 시작된다.
➁ 1번에서 작업이 끝나면 그다음 completeWork() 함수를 실행해 파이버 작업을 완료한다.
➂ 형제가 있다면 형제로 넘어간다.
➃ 2번, 3번이 모두 끝났다면 return으로 돌아가 자신의 작업이 완료됐음을 알린다.

### 2.2.5 정리
    가상 DOM과 리액트의 핵심은 값으로 UI를 표현하는 것이다.
화면에 표시되는 UI를 배열과 같이 값으로 관리하고 이러한 흐름을 효율적으로 관리하기 위한 메커니즘이 리액트의 핵심이다.

## 2.3 클래스 컴포넌트와 함수 컴포넌트
이에 대한 개념은 과거 클래스 컴포넌트에 대한 이해를 넓히거나 기존 리액트 코드를 리팩터링하고 유지보수하는 데 많은 도움이 될 것이다.

### 2.3.1 클래스 컴포넌트
클래스 컴포넌트를 만들기 위해서는 클래스를 선언하고 extends로 만들고 싶은 컴포넌트를 extends 해야 한다.
    extends 구문에 넣을 수 있는 클래스 
    : React.Component, React.PureComponent
▪ props : 컴포넌트에 특정 속성을 전달하는 용도로 쓰인다.
▪ state : 클래스 컴포넌트 내부에서 관리하는 값. 이 값은 항상 객체여야만 한다.
▪ 메서드 : 렌더링 함수 내부에서 사용되는 함수
    메서드를 만드는 방식
    1. constructor에서 this 바인드를 하는 방법
    2. 화살표 함수를 쓰는 방법
    3. 렌더링 함수 내부에서 함수를 새롭게 만들어 전달하는 방법
        -> 이 방법을 사용하면 최적화 수행에 어려움으로 지양하기

2. 클래스 컴포넌트의 생명주기 메서드
    생명주기 메서드가 실행되는 시점
    1. 마운트 : 컴포넌트가 생성되는 시점
    2. 업데이트 : 생성된 컴포넌트의 내용이 변경되는 시점
    3. 언마운트 : 컴포넌트가 더 이상 존재하지 않는 시점

render()
컴포넌트가 UI를 렌더링하기 위해 쓰임
업데이트와 마운트 과정에서 일어난다.
항상 순수해야 하며 부수 효과가 없어야 한다.
같은 입력값이 들어가면 항상 같은 결과물을 반환해야 한다는 뜻
따라서 render() 내부에서 state를 직접 업데이트하는 this.setState를 호출하면 안된다.

componentDidMount()
클래스 컴포넌트가 마운트되고 준비되면 그다음으로 호출되는 생명주기 메서드
this.setState()로 state값을 변경 가능
브라우저가 실제로 UI를 업데이트하기 전에 실행되어 사용자가 변경되는 것을 눈치챌 수 없게 만든다.

componentDidUpdate()
컴포넌트 업데이트가 일어난 이후 바로 실행된다.
this.setState()로 state값을 변경 가능
state나 props의 변화에 따라 DOM을 업데이트하는데 쓰인다.

shouldComponentUpdate()
state나 props의 변경으로 리액트 컴포넌트가 리렌딩되는 것을 막기 위해 쓰인다.

    Component와 PureComponent의 차이점
    Component : state가 업데이트되는 대로 렌더링이 일어난다.
    PureComponent : state 값에 대해 얕은 비교를 수행해 결과가 다를 때만 렌더링을 수행한다.

static getDerivedStateFromProps()
componenetWillReceiveProps를 대체할 수 있는 메서드
render()를 호출하기 직전에 호출됨

getSnapShotBeforeUpdate()
componentWillUpdate()를 대체할 수 있는 메서드
DOM이 업데이트 되기 직전에 호출되며, 반환된 값은 componentDidUpdate로 전달된다. 
DOM이 렌더링되기 전에 윈도우 크기를 조절하거나 스크롤 위치를 조정하는 등의 작업을 처리하는 데 유용하다.

getDerivedStateFromError()
자식 컴포넌트에서 에러가 발생했을 때 호출되는 에러 메서드
부수 효과를 추가한다고 해서 에러가 발생하지는 않지만, 굳이 부수 효과를 추가할 필요는 없다.

componentDidCatch
자식 컴포넌트에서 에러가 발생했을 때 실행되며, getDerivedStateFromError에서 에러를 잡고 state를 결정한 이후에 실행됨

#### 클래스 컴포넌트의 한계
▪ 데이터의 흐름을 추적하기 어렵다.
▪ 애플리케이션 내부 로직의 재사용이 어렵다.
▪ 기능이 많아질수록 컴포넌트의 크기가 커진다.
▪ 클래스는 함수에 비해 상대적으로 어렵다.
▪ 코드 크기를 최적화하기 어렵다.
▪ 핫 리로딩을 하는 데 상데적으로 불리하다.
    핫 리로딩
    : 코드에 변경 사항이 있을 때 앱을 다시 시작하지 않고서도   
    해당 변경된 코드만 업데이트해 변경 사항을 적용하는 기법

### 2.3.2 함수 컴포넌트
render 내부에서 필요한 함수를 선언할 때 this 바인딩을 조심할 필요 없음
state는 객체가 아닌 각각의 원시값으로 관리되어 사용이 편리
state는 객체를 관리할 수 있다.
return에서도 굳이 this를 사용하지 않더라도 props와 state에 접근할 수 있다.

### 2.3.3 함수 컴포넌트 vs. 클래스 컴포넌트
#### 생명주기 메서드의 부재
함수 컴포넌트 : props를 받아 리액트 요소만 반환하는 함수
클래스 컴포넌트 : render 메서드가 있는 React.Component를 상속받아 구현
즉, 생명주기 메서드는 React.Component에서 오기 때문에 생명주기 메서드를 사용할 수 없음

#### 함수 컴포넌트와 렌더링된 값
함수 컴포넌트는 렌더링된 값을 고정하고, 클래스 컴포넌트는 그렇지 못하다.
함수 컴포넌트는 렌더링이 일어날 때마다 그 순간의 값인 props와 state를 기준으로 렌더링된다.
props와 state가 변경되면, 다시 한 번 그 값을 기준으로 함수가 호출됨다.
클래스 컴포넌트는 시간의 흐름에 따라 변화하는 this를 기준으로 렌더링이 일어난다.

#### 클래스 컴포넌트를 공부해야 할까?
굳이 클래스 컴포넌트를 함수 컴포넌트로 변경할 필요는 없어보인다.
이제 리액트를 배우기 시작했다면 함수 컴포넌트로 작성하는 것이 좋다.
클래스 컴포넌트에 대한 지식은 어느 정도 필요하다.

## 2.4 렌더링은 어떻게 일어나는가?
### 2.4.1 리액트의 렌더링이란?
1. 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정
2. html 요소(element), 또는 React 요소 등의 코드가 눈으로 볼 수 있도록 그려지는 것

### 2.4.2 리액트의 렌더링이 일어나는 이유
[렌더링 발생 시나리오]
1. 최초 렌더링 : 사용자가 처음 애플리케이션에 진입하면 당연히 렌더링해야 할 결과물이 필요하다. 리액트는 브라우저에 이 정보를 제공하기 위해 최초 렌더링을 수행한다.
2. 리렌더링 : 처음 애플리케이션에 진입했을 때 최초 렌더링이 발생한 이후로 발생하는 모든 렌더링
    [리렌더링이 발생하는 경우]
    ▪ 클래스 컴포넌트의 setState가 실행되는 경우
    ▪ 클래스 컴포넌트의 forceUpdate가 실행되는 경우
    ▪ 함수 컴포넌트의 useState()의 두 번째 배열 요소인 setter가 실행되는 경우
    ▪ 함수 컴포넌트의 useReducer()의 두 번째 배열 요소인 dispatch가 실행되는 경우
    ▪ 컴포넌트의 key props가 변경되는 경우
```java
const arr = [1, 2, 3]
export default function App() {
    return (
        <ul>
            {arr.map((index) => (
                <li key={index}>{index}</li>
            ))}
        </ul>
    )
}
```

### 2.4.3 리액트의 렌더링 프로세스
렌더링 프로세스가 시작되면 리액트는 컴포넌트의 루트에서부터 차근차근 아래쪽으로 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾는다.
여기서 업데이트가 필요하다고 지정된 컴포넌트를 발견하면 클래스 컴포넌트의 경우 클래스 내부의 render() 함수를 실행하게 되고, 함수 컴포넌트의 경우 FunctionComponent() 자체를 호출한 뒤에, 그 결과물을 저장한다.
    리액트의 렌더링은 렌더 단계와 커밋 단계 총 두 단계로 분리되어 실행된다.
### 2.4.4 렌더와 커밋
#### 렌더 단계
컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업
렌더링 프로세스에서 컴포넌트를 실행해 이 결과와 이전 가상 DOM을 비교하는 과정을 거쳐 변경이 필요한 컴포넌트를 체크하는 단계
key, props, key 중 하나라도 변경되면 변경이 필요한 컴포넌트로 체크
#### 커밋 단계
렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 과정
리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니다.
#### 동시성 렌더링
렌더링 중 렌더 단계가 비동기로 작동해 특정 렌더링의 우선순위를 낮추거나, 필요하다면 중단하거나 재시작하거나, 경우에 따라서 포기하는 것
이를 통해 브라우저의 동기 작업을 차단하지 않고 백그라운드에서 새로운 리액트 트리를 준비할 수도 있으므로 사용자는 더욱 매끄러운 사용자 경험을 느낄 수 있다.

### 2.4.5 일반적인 렌더링 시나리오 살펴보기
컴포넌트를 렌더링하는 작업은 별도로 렌더링을 피하기 위한 조치가 돼 있지 않는 한 하위 모든 컴포넌트에 영향을 미친다. 
그리고 부모가 변경됐다면 props가 변경됐는지와 상관없이 무조건 자식 컴포넌트도 리렌더링된다.

### 2.4.6 정리
리액트에서 일어나는 렌더링 시나리오를 정확히 이해한다면 컴포넌트의 트리 구조를 개선하거나 불필요한 렌더링 횟수를 줄임으로써 성능 좋은 리액트 웹 애플리케이션을 만드는 데 도움이 될 것이다.

## 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션
useMemo, useCallback, memo -> 리액트에서 발생하는 렌더링을 최소한으로 줄여준다.
이러한 메모이제이션은 언제 사용하는 것이 좋을까?

### 2.5.1 주장1:섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모제이션을 추가하자
가벼운 작업은 메모이제이션보다 매번 이 작업을 수행해 결과를 반환하는 것(단순히 자바스크립트에서 실행시키는 것)이 빠를 수 있다.
메모이제이션도 비용이 드므로 최적화는 항상 경계해야 한다.

### 2.5.2 주장2:렌더링 과정의 비용은 비싸다. 모조리 메모이제이션해 버리자
리액트는 이전 렌더링 결과를 다음 렌더링과 구별하기 위해 저장해 둬야 한다. 그것이 기본적인 리액트의 재조정 알고리즘이다.
즉, 이전 결과물은 어떻게든 저장해두고 있기 때문에 우리가 memo로 지불해야하는 비용은 props에 대한 얕은 비교뿐이다.
리렌더링이 발생할 때 메모이제이션이 없다면 모든 객체는 재생성되고, 결과적으로 참조는 달라진다.
메모이제이션은 하지 않는 것보다 메모이제이션 했을 때 더 많은 이점을 누릴 수 있다. 

### 2.5.3 결론 및 정리
현업에서 리액트를 사용하거나 실제로 다룰 예정이지만 성능에 대해 깊게 연구해 볼 수 없는 상황이라면 일단 의심스러운 곳에는 먼저 다 적용해 볼 것을 권장한다.



