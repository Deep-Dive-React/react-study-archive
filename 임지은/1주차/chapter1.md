# 01장 | 리액트 개발을 위해 꼭 알아야 할 자바스크립트
## 1.1 자바스크립트의 동등 비교
### 1.1.1 자바스크립트의 데이터 타입
- 원시타입 : boolean, null, undefined, number, string, symbol, bigint<br>
    **`undefined` vs `null`**<br>
    `undefined` : 선언됐지만 할당하지 않은 값<br>
    `null` : 명시적으로 비어 있음을 나타내는 값<br><br>
- 객체타입 : object<br>
    = 참조타입
    ```javascript
    const hello1 = function() {
    }
    const hello2 = function() {
    }

    hello1 == hello2 // false
    ```

### 1.1.2 값을 저장하는 방식의 차이
- 원시타입 : 불변 형태의 값으로 저장
- 객체타입 : 객체는 프로퍼티를 삭제, 추가, 수정할 수 있으므로 값을 복사할 때도 값이 아닌 **참조**를 전달

### 1.1.3 자바스크립트의 또 다른 비교 공식, Object.js
    Object.js 
    ES6에서 새롭게 도입된 비교 문법
`==`  vs `Object .js`<br>
`==` : 강제로 형변환 후 비교 <br>
`Object.js` : 형태까지 고려하여 비교<br>
<br>
`===`  vs `Object .js`<br>
Object.js가 좀 더 개발자가 기대하는 방식으로 정확히 비교

### 1.1.4 리액트에서의 동등 비교
    리액트에서 사용하는 동등비교는 Object.js 이다.
*Object.js는 참조가 다른 **객체**에 대해 비교가 불가능하다*<br>
리액트의 비교 방식은 다음과 같다.
1. Object.js로 비교 수행
2. 만약 참조가 다른 객체라면, 객체 간 얕은 비교를 한번 더 수행
    - 객체의 1 depth까지만 비교 가능<br>
    -> 리액트의 props는 일반적으로 단일 객체

### 1.1.5 정리
동등비교를 잘 숙지하면, 리액트에서
- 훅의 의존성 배열의 비교
- 렌더링 방지를 넘어선 useMemo와 useCallback의 필요성
- 렌더링 최적화를 위해서 꼭 필요한 React.memo 

에 대해 쉽게 이해할 수 있다

## 1.2 함수
### 1.2.1 함수란 무엇인가?
리액트에서 사용하는 함수는

    Component라고 하는 함수를 선언하고 매개변수로는 일반적으로 props라고 부르는 단일 객체를 받으며 return문으로 JSX를 반환

### 1.2.2 함수를 정의하는 4가지 방법
1. 함수 선언문
```javascript
function add(a,b) {
    return a+b
}
```
2. 함수 표현식
```javascript
const sum = function (a, b) {
    return a+b
}	
sum(a,b)
```

함수 표현식 vs 함수 선언식<br>
`호이스팅(hoisting) 여부`<br>
`hoising` : 함수 선언문이 마치 코드 맨 앞단에 작성된 것처럼 작동하는 자바스크립트의 특징<br>
작동 원리 => 함수에 대한 선언을 실행 전에 미리 메모리에 등록하는 작업 진행

    함수 선언식 => 호이스팅 발생
    함수 표현식 => 호이스팅 발생 X

3. Function 생성자 : 거의 사용 안함
4. 화살표 함수<br>
ES6에서 새롭게 추가된 함수 생성 방식<br>
function이라는 키워드 대신 `=>` 라는 화살표 활용해서 함수 만듦
```javascript
const add = (a,b) => {
    return a+b
}
```
    화살표 함수의 차이점
    1. constructor 사용 X
    2. arguments 존재 X
    3. this 바인딩 
        일반 함수 = 내부의 this는 전역 객체를 가리킨다.
        화살표 함수 = 상위 스코프의 this를 그대로 따르게 된다.
    
### 1.2.3 다양한 함수 살펴보기
1. 즉시 실행 함수 => 함수 정의 후 그 즉시 바로 실행
2. 고차 함수 => 함수에서 함수를 인수로 받거나, 결과로 새로운 함수 반환

## 1.3 클래스
### 1.3.1 클래스란 무엇인가?
    인스턴스 메서드
    => 클래스 내부에서 선언한 메서드

        인스턴스 메서드는 실제로 자바스크립트의 prototype에 선언되므로 프로토타입 메서드로 불리기도 한다. 

        [프로토타입에 들어갔는지 확인하는 방법]
        Object.getPrototypeOf
    
    정적 메서드
    => 클래스의 인스턴스가 아닌 이름으로 호출할 수 있는 메서드
    
        인스턴스를 생성하지 않아도 사용할 수 있다.
        객체를 생성하지 않더라도 여러 곳에서 재사용 가능 
        => 애플리케이션 전역에서 사용하는 유틸 함수를 정적 메서드로 많이 활용한다!

## 1.4 클로저
### 1.4.1 클로저의 정의
리액트의 클래스 컴포넌트에 대한 이해가 자바스크립트의 `클래스`, `프로토타입`, `this` 에 달려있다면, 함수 컴포넌트에 대한 이해는 `**클로저**`에 달려있다!!

    클로저의 정의
    함수와 함수가 선언된 어휘적 환경의 조합
    => 쉽게 풀어서 설명하자면, 함수 안에 또 다른 함수가 있을 때 각각의 함수는 변수를 가지고 있는데 해당 변수가 어떤 함수의 변수인지! 를 조합해 코딩하는 기법

### 1.4.2 변수의 유효 범위, 스코프
스코프 = 변수의 **유효 범위**
1. 전역 스코프 : 어디서든 호출 가능 
2. 함수 스코프 : 자바스크립트는 기본적으로 함수 레벨 스코프를 따른다.

### 1.4.3 클로저의 활용
리액트에서 전역 스코프를 사용하면, 누구든 변수 값에 접근 가능하고 변경할 수 있기에 문제가 된다. <br>
따라서 리액트의 변수에 아무나 접근하지 못하도록 해야 한다.<br>

    리액트가 관리하는 내부 상태 값은 리액트가 별도로 관리하는 클로저 내부에서만 접근할 수 있다.

[리액트에서 클로저 활용한 대표적 예]<br>
`useState`
```javascript
function Component() {
    const [state, setState] = useState()

    function handleClick() {
        setState((prev) => prev + 1)
    }
}
```
- useState 호출은 위에서 끝났지만, setState는 계속 내부의 최신값을 알고 있다.

### 1.4.4 주의할 점
클로저가 선언된 순간 내부함수는 외부함수의 선언적인 환경을 기억하고 있어야 한다!

## 1.5 이벤트 루프와 비동기 통신의 이해
- 동기(synchronous) : 직렬 방식, 순서대로, 다른 작업들 대기
- 비동기 (asynchronous) : 병렬 방식, 요청 후 응답 기다리지 않고 다른 작업 처리, 한 번에 여러 작업 실행
### 1.5.1 싱글 스레드 자바스크립트
- 프로세스
    - 프로그램을 구동해 프로그램의 상태가 메모리상에서 실행되는 작업 단위
- 스레드
    - 더 작은 실행 단위
    - 하나의 프로세스에는 여러 개의 스레드를 만들 수 있고, 스레드끼리는 메모리를 공유할 수 있어 여러가지 작업들을 동시에 할 수 있다. 

[자바스크립트 싱글 스레드]<br>
자바스크립트 코드의 실행이 하나의 스레드에서 순차적으로 이루어진다는 것을 의미 => 동기식

그렇다면 자바스크립트에서 비동기 코드 처리 방법?<br>
`이벤트 루프`
    
### 1.5.2 이벤트 루프란?
    이벤트 루프?
    자바스크립트 런타임 외부에서 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치

    - 호출 스택 : 자바스크립트에서 수행해야 할 코드나 함수를 순차적으로 담아두는 스택
    - 태스크 큐
      비동기 함수의 콜백 함수나 이벤트 핸들러가 들어감
      큐가 아니라 set의 형태
      why? 선택된 큐 중에서 실행 가능한 가장 오래된 태스크를 가져와야 하므로
        
### 1.5.3 태스크 큐와 마이크로 태스크 큐

    마이크로 태스크 큐 => Promise
    마이크로 태스크 큐는 기존 태스크 큐보다 우선권을 갖는다.

    - 태스크 큐 : setTimeout, setInterval, setImmediate
    - 마이크로 태스크 큐 : process.nextTick, Promises, queueMicroTask, MutationObserver

    렌더링 발생 시기
    마이크로 태스크 > 렌더링 > 태스크


## 1.6 리액트에서 자주 사용하는 자바스크립트 문법
바벨 : 자바스크립트의 최신 문법을 다양한 브라우저에서도 일관적으로 지원할 수 있도록 코드를 트랜스파일

### 1.6.1 구조 분해 할당
- 배열 구조 분해 할당
- 객체 구조 분해 할당
### 1.6.2 전개 구문
`...`

### 1.6.3 객체 초기자
    객체를 선언할 때 객체에 넣고자 하는 키와 값을 가지고 있는 변수가 이미 존재한다면 해당 값을 간결하게 넣어줄 수 있는 방식

### 1.6.4 Array 프로토타입의 메서드: map, filter, reduce, forEach
기존 배열의 값을 건드리지 않고, 새로운 값을 만들어낸다!

### 1.6.5 삼항 조건 연산자
조건문 ? 참 : 거짓

## 1.7 선택이 아닌 필수, 타입스크립트
### 1.7.1 타입스크립트란?
기존 자바스크립트 문법에 타입을 가미한 것
타입 체크를 런타임이 아닌 빌드(트랜스파일) 타임에 수행할 수 있게 해준다.

### 1.7.2 리액트 코드를 효과적으로 작성하기 위한 타입스크립트 활용법
1. any 대신 unknown을 사용하자<br>
대신 타입을 사용하는 쪽에서는 최대한 타입을 좁히자

타입 가드를 좁히는데 도움을 주는 것 => `타입 가드`

[타입 가드]
- instanceof : 지정한 인스턴스가 특정 클래스의 인스턴스인지 확인
- typeof : 특정 요소에 대한 자료형 확인
- in : 어떤 객체에 키가 존재하는지 확인

2. 제네릭<br>
단일 타입이 아닌 다양한 타입에 대응하도록 도와주는 도구
```javascript
function getFirstAndLast<T>(list: T[]): [T,T] {
    return ~~~
}
// <T> <- 제네릭 선언
// list: T[] <- 배열 
// [T,T] <- 반환값
```