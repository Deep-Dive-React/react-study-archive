# 1. 리액트 개발을 위해 알아야 하는 JS 문법

## 1.1 Javascript의 동등 비교


- 리액트에서 렌더링이 일어나는 이유 - `props` 의 `동등 비교` 에 따른 결과.
- props의 동등 비교는 객체의 `얕은 비교`를 기반으로 이뤄지는데, 이 `얕은 비교`가 리액트에서 어떻게 작동하는지 이해하지 못하면 렌더링 최적화에 어려움을 겪을 가능성이 큼 


## 자바스크립트 자료형

1. 원시 타입 (primitive type)
``` 
boolean, number, string, null, undefined, bigint, symbol
```

- **falsy한 값** :  false(Boolean), 0 (Number), NaN (Number), '' (String), null (null), undefined(undefined) 
- Number 저장 범위 : -( 2의 53승 -1 ) ~ +( 2의 53승 -1 )), 이보다 더 큰 숫자는 BigInt로 만든다. 


Bigint를 만드는법은, 숫자 끝에 n을 붙이거나 BigInt함수를 통하여 생성할 수 있다.

Symbgol은 중복되자 않는 어떤 고유한 값을 나타내기 위해 만들어졌다. 심벌 생성을 위해선 `Symbol()` 을 반드시 사용해야 한다.



2. 객체
- object

객체 타입의 경우 배열, 함수, 정규식, 클래스 등이 포함된다.  (원시 타입 7가지 경우 제외한 모든 케이스)

>>
원시타입과 객체 타입을 구분 짓는 결정적인 차이는 **값을 저장하는 방식** 의 차이다. 원시타입의 `불변 형태의 값` 으로 저장되는 반면, 객체는 프로퍼티를 삭제, 추가, 수정할 수 있으므로 `변경 가능한 형태` 로 저장되며 값을 복사할 때도 값이 아닌 참조를 전달하게 된다.



**소결론 1**

객체 간의 비교가 발생할 때, 객체의 참조값을 비교하기 때문에 우리가 이해하는 값이 같다고 해도 결과는 대부분 true가 아님을 인지해야 한다.

### == (동등 연산자), ===(일치 연산자), Object.is

자바스크립트에서 비교를 위해선 ==, ===연산자를 활용한 비교와 Object.is 메서드를 통한 비교를 할 수 있다. 

- Object.is 가 ==나 ===와 다른 점은, == 비교의 경우 같음을 비교하기 전에 양쪽이 같은 타입이 아니라면 비교할 수 있도록 강제로 형변환을 한 후 (type casting) 값이 동일하다면 true를 반환하는 반면, Object.is는 ===와 동일하게 타입이 다르면 그냥 false를 반환한다.

- === 와 Object.is의 경우에도 몇가지 차이점이 있다. 예를 들어서

```javascript
-0 === +0 // true
Object.is(-0,+0) // false
Number.Nan === Nan // false
Object.is(Number.Nan, Nan) // true
Nan === 0/ 0 // false
Object.is(Nan, 0/0) // true

```
=== 의 기존의 예상치 못한 동작을 보완하기 위해서 Object.is가 생성되었지만, 객체 비교에 있어서는 얕은 비교를 수행하므로 예상되는 동작과 여전히 다르게 동작한다. 


**리액트**에서 사용하는 동등 비교는 `Object.is` 다. 

리액트에서의 비교는 Object.is로 먼저 비교를 수행한 다음에 Object.is에서 수행하지 못하는 비교를 한번 더 수행한다.




## 1.2 함수
함수를 정의하는 데는 4가지 방법이 있다.
1. 함수 선언문 
2. 함수 표현식 
3. Function 생성자
4. 화살표 함수 

함수 선언문과 함수 표현식의 차이는 `호이스팅` 이 일어나는 과정에서  갈린다! 두가지 모두 함수 실행 시 호이스팅이 일어나는데, 함수 표현식의 경우에 `var`에 함수가 할당이 될 경우 호이스팅 되는 시점에서  `undefined` 로 초기화되는 차이점이 있다! 

화살표함수는 ES6에서 새롭게 추가된 방식으로, 최근 각광받고 있는 함수 정의 방식이다. 깔쌈하니까 ㅎ

 화살표 함수는 함수 선언문과 표현식과 다른 몇 가지 특징이 있다.
 `constructor` 사용이 안되고, `arguments`가 존재하지 않으며 화살표 함수 내부에서 this를 참조할 상위 스코프의 `this` 를 따르게 된다. 


`즉시 실행 함수` 는 함수를 정의하고 그 순간 즉시 실행되는 함수를 의미한다. 재사용되지 않고 단 한번만 실행되고 끝난다면 사용을 검토해볼 수 있겠다!
```javascript
(function(a,b){
    return a+b
})(10,24); // 34

((a,b)=>{
    return a+b
})(10,24); // 34

```


 함수를 인수로 받거나 결과로 새로운 함수를 반환시키는 함수를 `고차 함수` 라고 한다. 대표적으로 함수를 매겨변수로 받아 결과를 반환하는 `.map` 함수가 있다. 

 
 ## 1.4 클로저 

리액트의 함수형 컴포넌트 작성에 이해를 위해선 클로저라는 개념을 이해하고 있어야 한다. 

클로저는 망말 어려운 개념인 거 같다.. 다시 한 번 말로써 정리해보자면

```
클로저는 함수와 함수가 선언된 어휘적 환경 (Lexical Scope) 의 조합이다.
```

이 렉시컬 스코프.. 에 대해서는 좀 더 나중에 깊게 다뤄보도록 하고, 리액트에서의 클로저라는 개념이 어떻게 사용되는지 보자. 

리액트에서 업데이트한 `state` 의 최신 상태를 `setState`에서 `prev` 로 계속해서 확인할 수 있는 이유는 바로 클로저가 `useState` 내부에서 활용되었기 때문이다.

## 1.5 이벤트 루프와 비동기 통신의 이해
`이벤트 루프`란 자바스크립트 런타임 외부에서 자바스크립트의 `비동기 실행` 을 돕기 위해 만들어진 장치라고 볼 수 있다. 

```javascript
function bar(){
    console.log('bar');
}

function baz(){
    console.log('baz');
}

function bae(){
    console.log('bae');
    bar();
    baz();
}
```

bae 호출 스택 스택 들어감 - bar 호출 스택 들어감 - bar 실행 완료 후 스택에서 제거 - baz 호출스택들어감 - baz 호출스택에서 제거 - bae 호출 스택에서 제거 ..

이런 식으로 `호출 스택`에 js에서 수행해야 될 코드나 함수가 담기게 됨.

`이벤트 루프`가 하는 일이 바로 이 `호출 스택`이 제대로 비어 있는지 여부를 확인하는 것임. 이벤트 루프는 단순히 이벤트 루프만의 단일 스레드 내부에서 호출 스택 내부에서 수행해야될 작업을 확인 - 실행한다 (JS 엔진 이용).  

여기서 키포인트는 `코드 실행` 과 `호출 스택이 비어있는지 확인` 하는 것 모두가 단일 스레드에서 일어난다는 점이다. 두가지 작업은 동시에 일어날 수 없으며❌, 스레드에서 순차적으로 일어난다. 


아래는 비동기 작업의 실행 예다.

```js
function bar(){
    console.log('bar')
}
function baz(){
    console.log('baz')
}
function foo(){
    console.log('foo');
    setTimeout(bar(),0);
    baz(); 
}
```

foo 호출스택 -  setTimeout(bar(),0) 호출스택 들어감 - setTimeout 태스트큐로 들어가고 호출스택에서 곧바로 제거 - baz 호출스택 - baz 호출스택 제거 - foo에 남은 게 없으므로 호출 스택에서 제거 - `이벤트 루프` 가 `호출스택` 이 비워져 있는 거 확인하고 테스트 큐 확인 - bar 호출스택 - bar 호출스택 제거

- 여기 테스트 큐에서 큐는 queue 가 아닌 set형태를 띔. 


**소결론**

이벤트 루프의 역할은 호출 스택에 실행 중인 코드가 있는지, 태스트 큐에 대기 중인 함수가 있는지 반복해서 확인하는 역할을 한다. 

비동기 함수의 처리는 함수의 메인 스레드가 아니라 태스크 큐가 할당되는 별도의 스레드에서 수행된다. 이 별도의 스레드에서 태스크 큐에 작업을 할당해 처리하는 것은 브라우저 혹은 Node.js의 역할이다. 
즉 자바스크립트 코드 실행은 싱글 스레드 안에서 이뤄지지만, 외부 Web API 등은 외부에서 실행되고 콜백이 태스크 큐로 들어가는 것이다.

이벤트 루프의 역할은, 호출 스택이 콜백이 실행 가능할 때가 올 때 이것을 꺼내서 수행하는 역할을 하는 것이다! 


## 1.6

배운 점

- 객체 분해 할당을 객체 전개 연산자를 통하여 하면 트랜스파일 될 시 번들링이 커져 사용할 때 주의할 필요가 있다


- `Array.forEach` 메서드를 사용할 경우, 실행될 떄 에러를 던지거나 프로세스를 종료하지 않는 이상 이를 멈출 수 없다. break, return, 그 무엇을 이용해도 배열 순회는 멈출 수 없다.! 또한 시간복잡도가 O(n) 이므로 최적화 가능성을 생각해보자~!


- 삼항 연산자,,, 너무 중첩해서 쓰지 말자..


## 1.7 타입스크립트 

- 불가피하게 타입을 단정할 수 없을 때는 any 말고 unknown 타입을 사용하자. unknown 사용할 때는 `type narrowing` 을 해야함!



 
