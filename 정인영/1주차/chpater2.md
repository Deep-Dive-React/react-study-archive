# 2. 리액트 핵심 요소 깊게 살펴보기


JSX가 포함된 코드를 아무런 처리 없이 실행하면 에러가 발생한다. JSX는 JS 표준문법 (ECMAScript) 이 아닌 (아니었구나..?) 페북이 만든 새로운 문법이므로 반드시 트랜스파일러를 거쳐야 자바스크립트 런타임이 이해할 수 있는 JS 코드로 변환된다.




## 2.2 가상돔과 리액트 파이버 
## [ 브라우저의 렌더링 과정과 리액트 Virtual Dom의 도입]

(웹서버로 이미 연결이 된 후를 가정)
### 0. Response
먼저 브라우저는 유저 대신에 웹 서버로 `HTTP GET` 요청을 보내고, 서버는 `html` 파일을 응답한다.

### 1. Parsing (DOM Tree 생성)


브라우저는 네트워크를 통해 받은 데이터를 파싱하여 `DOM Tree` 를 구축한다. 
1-1 .먼저 `HTML` 파일의 파싱과정이 이루어지는데, `변환`- `토큰화` - `렉싱` - `DOM 생성` 의 프로세스를 거치게 된다. 
![](https://velog.velcdn.com/images/rmdnps10/post/5dee1e5c-423e-4a88-be81-3dc8f2d82431/image.png)

브라우저는 HTML의 원시 바이트를 읽어 `변환` 과정에서  HTML 인코딩에 따라 개별 문자열로 변환하고, 이 문자열은 토큰으로 변화하여 `렉싱` 과정에서 `객체`로 변환되어 `DOM Tree` 구축이 완료된다.





1-2 . 동일한 방식으로 CSS를 파일을 읽어와서 `CSSOM Tree` 를 구축한다.

CSS가 분석되고 `CSSOM Tree`이 생성되는 동안, 프리 스캐너 덕에 Javascript 파일 같은 다른 자원도 다운로드 된다.  


### 2.Rendering 

2-1.`렌더 트리` 생성

`CSSOM Tree` 와 `DOM Tree`는 `렌더 트리`로 합성된다. 렌더링 트리는 페이지를 렌더링 하는데 필요한 노드만 계산한다. 즉 `display:none` 과 같은 속성을 가지고 노드는 렌더링 과정에서 렌더 트리에 포함되지 않는데, 웹 접근성을 위해서 요소를 숨겨줄 때는 `display : none` 을 쓰면 안된다. 


2-2. `레이아웃`  (`리플로우`) 

레이아웃 단계에서는 `렌더 트리`를 순회하면서 초기 각 노드의 사이즈와 위치를 계산한다.
개발자의 의도에 따라 스타일이 달리지거나, 브라우저 크기가 달라질 경우 `레이아웃` 단계가 다시 발생하게 된다.

2-3. `페인트` (`리페인트`)
`페인트` 단계는 렌더 트리의 노드를 말 그대로 스타일을 적용하여 그리는 과정이다.
`리페인트` 과정은 요소의 사이즈, 위치의 변경으로 인한 `리플로우` 과정이 일어나 일어나 다시 노드를 다시 그려야 할 때 일어나거나, 레이아웃을 건들지 않는 예로써 노드의 background-color, visibillty, outline 등의 스타일 변경 시에는로 `리플로우` 과정이 생략된 `리페인트` 과정만 일어나게 된다.

- `transform` 과 `opacity`의 경우 속성 값에 따른 `레이아웃` 단계와 `리페인트` 단계를 생략한다. 왜냐하면`렌더 트리`에 포함되지 않기 때문이다. 대신 GPU가 관할한다.
![](https://velog.velcdn.com/images/rmdnps10/post/f6a4e54f-1f21-4ec2-b5da-92a8293dab2d/image.png)

> 리플로우가 일어나는 속성 : position, width, height, margin, padding, border, border-width, font-size, font-weight, line-height, text-align, overflow



리페인트만 일어나는 속성 : background, color, text-decoration, border-style, border-radius

2-4. `컴포지션`
각 섹션이 다른 레이어에서 그려질 때, 섹션을 겹쳐놓으면서 그것들이 올바른 순서로 화면에 그려지는 것 (z-index) 과 정확한 렌더링을 보장하기 위해 합성이 필요하고, 이를 `컴포지션` 작업이라고 한다.

### 문제점 

스타일이 변경되었을 때 실행되는 레이아웃 과정과 리페인트 과정은 전체 렌더 트리를 순회하는 작업을 수반하기 때문에 비용이 상당히 든다. 그러므로 최대한 렌더링 과정의 뒤쪽 단계, `리페인트`- `컴포지션` , 혹은 `컴포지션` 단계만 이뤄지게 하는 게 `브라우저 최적화` 를 할 때 의식해야 할 점이다. (나중에 최적화에 대해서는 따로 다뤄보도록 하자.)

하지만 아무리 최적화를 해도 `렌더링 트리` 의 하나의 노드가 변경되었을 때 트리 전체를 순회하여 레이아웃, 리페인트 과정을 거쳐야 한다는 것은 변하지 않는데, 이러한 문제점을 해결하는 것이 바로 리액트의 `Virtual Dom`이다.





### Virtual Dom 의 동작 방식

`Virtual DOM`은 실제 DOM 의 복사형태이며, 복사본은 실제 DOM이 아닌 JS 객체 형태로 메모리에 저장되어 있다. 또한, 실제 DOM과 다르게 직접적으로 브라우저 화면의 UI를 조작할 수 있게 해주는 API는 제공하지 않는다. 

리액트는 항상 2개의 Virtual Dom Tree 들을 가지고 있다. 바로 상태 `렌더링 이전의` DOM tree 와 `렌더링 이후` 의 DOM tree이다. 리액트에서 리렌더링이 발생하는 조건 중에 상태가 변화하여 화면에 `리페인트`되는 과정까지를 살펴보자.


1. 리액트는 리렌더링이 발생할 때 위에서 언급했던 두개의 tree를 비교하여 정확히 어떤 Element가 변했는지를 비교한다. (`Diffing`)
2. 이후 실제 DOM tree에 차이가 발생한 부분만 반영한다 (`Reconcilation`). 
3. 브라우저는 새롭게 변경된 DOM과 CSSOM을 결합하여 Render tree를 생성하여 화면에 `리페인트` 한다. 

`Diffing` 과정에서는  `DFS` 방식을 통해 변경된 노드를 탐색한다.
`Reconcilation` 과정에서는, `state`를 한번에 여러개를 업데이트 할 수 있도록 `React Batch Update` 를 사용한다. 이러한 과정에서 `setState`  비동기적으로 작동하고,  state의 값이 변경되는 시점은, `setState`가 호출되는 시점이 아닌, 해당 코드가 포함된 함수가 모두 실행된 이후이다. 이렇게 하면 여러 개의 상태를 업데이트할 때 하나씩 업데이트 되면서 리렌더링을 발생시키지 않고, 한번에 state를 업데이트 할 수 있다.

> 리액트는 컴포넌트의 렌더링 횟수를 최소화하기 위해서 State Batch Update를 사용한다. 이는 리액트의 이벤트 핸들러를 사용하여 여러 번의 `setState`를 호출할 때 이를 하나의 업데이트로 일괄 처리하여 리렌더링이 한 번만 발생하도록 하는 것이다. 

[출처](https://sunho-doing.tistory.com/entry/Reactjs-useState%EC%9D%98-%ED%8A%B9%EC%A7%95State-Batch-Update-%EB%B9%84%EB%8F%99%EA%B8%B0)


## 결론

즉, 리액트의 `Virtual DOM`은 두개의 가상 tree와 `Diffing` 과 `Reconcilation`의 방식을 통해 기존의 브라우저의 동작 방식 (리페인트와 리플로우가 일어날 때마다 전체 트리 순회를 하는 과정)보다 효율적으로 화면을 업데이트할 수 있다. 


## 2.5 

리렌더링이 발생하여 참조가 달라지는 객체를 의존성 배열에 넣었을 때 계속해서 useEffect 내 콜백 함수가 실행이 된다면.. useMemo감싸보자
메모이제이션을 하지 않는 것보단,, 하는 게 좋다.




